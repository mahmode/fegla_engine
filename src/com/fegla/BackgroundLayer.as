package com.fegla 
{
	import starling.display.Image;
	import starling.display.QuadBatch;
	import starling.display.Sprite;
	import starling.textures.Texture;
	
	/**
	 * Background layer is a layer in the level background, each background layer can have its own parallax value.
	 * The background layer automatically copies its texture in the x and y direction to twice the level size to 
	 * provide the scrolling effect. This class should not be instantiated directly, instead should be generated by called background.addLayer() method
	 * 
	 * @see Background#addLayer()
	 */
	public class BackgroundLayer extends Sprite
	{
		/**
		 * parallax defines the movement rate of the background layer relative to the world scrolling speed. A parallax value of 0 means the background layer is fixed, a value of 1 means the background layer moves at the same speed as the level, a value of 0.5 means the background layer moves at half the speed of the level...etc
		 */
		public var parallax:Number = 0;
		
		/**
		 * the width of the texture minus the overlap
		 * 
		 * @private
		 */
		internal var effectiveWidth:Number = 0;
		
		/**
		 * the height of the texture minus the overlap
		 * 
		 * @private
		 */
		internal var effectiveHeight:Number = 0;
		
		private var world:World;
		
		private var overlap:Number = 0;
		
		/**
		 * constructor
		 * 
		 * @param	world the fegla world
		 * @param	texture the background layer texture
		 * @param	parallax the parallax value of the layer, parallax defines how fast the background layer moves relative to the level scrolling speed.
		 * @param	overlap the amount of overlap between 2 adjacent repeated textures. Normally you do not need to change this value. But
		 * you can set this vlaue to fix some gliches like seeing a cutting line between 2 textures or fixing smooth matching between 2 textures.
		 */
		public function BackgroundLayer(world:World, texture:Texture, parallax:Number = 0, overlap:Number = 0)
		{
			this.world = world;
			this.parallax = parallax;
			this.overlap = overlap;
			
			setTexture(texture);
		}
		
		// set the layer texure and repeat it to match scrolling requirements
		private function setTexture(texture:Texture):void
		{
			while (numChildren > 0)
				removeChildAt(0);
			
			var view:Image = new Image(texture);
			var qb:QuadBatch = new QuadBatch();
			var i:int;
			var j:int;
			
			var repeatX:Boolean = false;
			var repeatY:Boolean = false;
			
			if (parallax != 0)
			{
				repeatX = world.levelWidth > world.viewWidth;
				repeatY = world.levelHeight > world.viewHeight;
			}
			
			if (repeatX && repeatY)
			{
				for (i = 0; i < 10; i++)
				{
					if (qb.width < 2 * world.viewWidth)
					{
						view.x = i * (view.width - overlap);
						qb.addImage(view);
						
						for (j = 0; j < 10; j++)
						{
							if (qb.height < 2 * world.viewHeight)
							{
								view.x = i * (view.width - overlap);
								view.y = j * (view.height - overlap);
								qb.addImage(view);
							}
							else break;
						}
					}
					else break;
				}
			}
			else if (repeatX)
			{
				for (i = 0; i < 10; i++)
				{
					if (qb.width < 2 * world.viewWidth)
					{
						view.x = i * (view.width - overlap);
						qb.addImage(view);
						
						for (j = 0; j < 10; j++)
						{
							if (qb.height < world.viewHeight)
							{
								view.x = i * (view.width - overlap);
								view.y = j * (view.height - overlap);
								qb.addImage(view);
							}
							else break;
						}
					}
					else break;
				}
			}
			else if (repeatY)
			{
				for (i = 0; i < 10; i++)
				{
					if (qb.width < world.viewWidth)
					{
						view.x = i * (view.width - overlap);
						qb.addImage(view);
						
						for (j = 0; j < 10; j++)
						{
							if (qb.height < 2 * world.viewHeight)
							{
								view.x = i * (view.width - overlap);
								view.y = j * (view.height - overlap);
								qb.addImage(view);
							}
							else break;
						}
					}
					else break;
				}
			}
			else
			{
				for (i = 0; i < 10; i++)
				{
					if (qb.width < world.viewWidth)
					{
						view.x = i * (view.width - overlap);
						qb.addImage(view);
						
						for (j = 0; j < 10; j++)
						{
							if (qb.height < world.viewHeight)
							{
								view.x = i * (view.width - overlap);
								view.y = j * (view.height - overlap);
								qb.addImage(view);
							}
							else break;
						}
					}
					else break;
				}
			}
			
			addChild(qb);
			
			effectiveWidth = view.width - overlap;
			effectiveHeight = view.height - overlap;
		}
	}
}