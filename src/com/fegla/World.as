package com.fegla 
{
	import com.fegla.events.AreaEvent;
	import com.fegla.events.OverlapEvent;
	import com.fegla.events.PlatformEvent;
	import com.fegla.texture.TextureTile;
	import com.greensock.easing.*;
	import com.greensock.TweenMax;
	import starling.display.DisplayObject;
	import starling.display.Image;
	import starling.display.Sprite;
	import starling.events.Event;
	import starling.textures.Texture;
	import starling.textures.TextureAtlas;
	
	/**
	 * This is the heart of the engine, it is where you load the level, simulate the forces...etc
	 * 
	 * @author Mahmoud Badri mhdside@hotmail.com
	 */
	public class World extends Sprite
	{
		/**
		 * Fegla world version
		 */
		public static const VERSION:String = "0.11";
		
		/**
		 * The hero is the human controlled character of the game
		 */
		public var hero:Hero;
		
		/**
		 * The camera controls what should be viewed on the game and how to view it
		 */
		public var camera:Camera;
		
		/**
		 * The gravity of the world, it affects the hero and the enemies
		 */
		public var gravity:Number = 1;
		
		/**
		 * The background of the world
		 */
		public var background:Background;
		
		public var currArea:Area;
		public var currPlatform:Platform;
		public var currLadder:Ladder;
		
		public var viscosity:Number = 1;
		
		public var areas:Vector.<Area>;
		public var platforms:Vector.<Platform>;
		public var ladders:Vector.<Ladder>;
		private var initialItemsCounts:Object;
		
		private var groups:Object;
		
		/**
		 * The visual view of the world, use this to add any objects to the world
		 */
		public var view:Sprite;
		
		/** @private */
		internal var levelWidth:Number;
		
		/** @private */
		internal var levelHeight:Number;
		
		/** @private */
		internal var viewWidth:Number;
		
		/** @private */
		internal var viewHeight:Number;
		
		// used locally in several methods
		private var evt:PlatformEvent;
		
		private var paused:Boolean = false;
		
		// array of 2 groups to check for overlaps
		private var overlapGroups:Array;
		
		// array of current overlaps
		private var overlaps:Vector.<Overlap>;
		
		
		private var textureAtlas:TextureAtlas;
		
		public static var instance:World;
		
		/**
		 * Constructor
		 */
		public function World()
		{
			if (!instance)
				instance = this;
			
			touchable = false;
			
			addEventListener(Event.ADDED_TO_STAGE, onAdded);
			addEventListener(Event.REMOVED_FROM_STAGE, onRemoved);
		}
		
		private function onAdded(e:Event):void 
		{
			removeEventListener(Event.ADDED_TO_STAGE, onAdded);
			
			viewWidth = stage.stageWidth;
			viewHeight = stage.stageHeight;
			
			background = new Background(this);
			addChild(background);
			
			view = new Sprite();
			addChild(view);
			
			camera = new Camera(this);
			
			groups = {};
			initialItemsCounts = {};
			overlapGroups = [];
			
			overlaps = new Vector.<Overlap>();
		}
		
		/**
		 * loads a level xml file to build a level.
		 * 
		 * @param data the level data xml file, this file should be generated by Fegla Editor, yet it is just a regular xml file that can be edited by hand.
		 */
		public function loadLevel(data:XML, textureAtlas:TextureAtlas):void
		{
			this.textureAtlas = textureAtlas;
			clearLevel();
			
			levelWidth = Number(data.@w);
			levelHeight = Number(data.@h);
			
			areas = new Vector.<Area>(data.ar.length());
			platforms = new Vector.<Platform>(data.pf.length());
			ladders = new Vector.<Ladder>(data.ld.length());
			
			var texs:Array;
			var texVect:Vector.<Texture> = new Vector.<Texture>();
			var tiles:Array = [];
			
			// add tiles
			for (var i:int = 0; i < data.tile.length(); i++)
			{
				texs = data.tile[i].@tex.split(",");
				texVect = new Vector.<Texture>();
				
				for (var j:int = 0; j < texs.length; j++)
					texVect[j] = textureAtlas.getTexture(texs[j]);
				
				tiles[int(data.tile[i].@id)] = new TextureTile(texVect);
			}
			
			// add areas
			for (i = 0; i < data.ar.length(); i++)
			{
				areas[i] = new Area(data.ar[i]);
				view.addChild(areas[i]);
			}
			
			// add platforms
			for (i = 0; i < data.pf.length(); i++)
			{
				platforms[i] = new Platform(data.pf[i]);
				view.addChild(platforms[i]);
				
				if ("@tileId" in data.pf[i])
					platforms[i].setViewFromTile(tiles[int(data.pf[i].@tileId)]);
			}
			
			// add ladders
			for (i = 0; i < data.ld.length(); i++)
			{
				ladders[i] = new Ladder(data.ld[i]);
				view.addChild(ladders[i]);
			}
			
			// add items
			if (data.itm.length() > 0)
			{
				var item:ImageItem;
				for (i = 0; i < data.itm.length(); i++)
				{
					item = new ImageItem(data.itm[i]);
					addItem(item, data.itm[i].@gId);
					
					if ("@taId" in data.itm[i])
						item.setViewFromTexture(textureAtlas.getTexture(data.itm[i].@taId));
				}
			}
			
			// save initial items count in each group
			for (var s:String in groups) 
				initialItemsCounts[s] = groups[s].length;
			
			// add hero
			if (data.hero.length() > 0)
			{
				hero = new Hero(data.hero[0]);
				view.addChild(hero);
				
				hero.name = "hero";
				groups.hero = [hero];
				
				camera.follow(hero);
			}
		}
		
		private function clearLevel():void
		{
			// remove areas
			if (areas)
			{
				for (var i:int = 0; i < areas.length; i++)
					view.removeChild(areas[i]);
				
				areas = null;
			}
			
			// remove platforms
			if (platforms)
			{
				for (i = 0; i < platforms.length; i++)
					view.removeChild(platforms[i]);
				
				platforms = null;
			}
			
			// remove ladders
			if (ladders)
			{
				for (i = 0; i < ladders.length; i++)
					view.removeChild(ladders[i]);
				
				ladders = null;
			}
			
			if (hero)
			{
				if (camera && camera.target == hero)
					camera.target = null;
				
				view.removeChild(hero);
				
				hero = null;
			}
		}
		
		/**
		 * get a platform by its id. This is useful when you want to wire some action to a specific platform (ex. open a gate upon touching a platform)
		 * 
		 * @param id The platform id as specified in the level xml file.
		 * @return the platform with the specified id
		 */
		public function getPlatformById(id:int):Platform
		{
			for (var i:int = 0; i < platforms.length; i++)
			{
				if (platforms[i].id == id) 
					return platforms[i];
			}
			
			return null;
		}
		
		/**
		 * get an area by its id. This is useful when you want to wire some action to a specific area (ex. open a gate upon touching an area)
		 * 
		 * @param id The platform id as specified in the level xml file.
		 * @return the platform with the specified id
		 
		 */
		public function getAreaById(id:int):Area
		{
			for (var i:int = 0; i < platforms.length; i++)
			{
				if (areas[i].id == id) 
					return areas[i];
			}
			
			return null;
		}
		
		/**
		 * get a ladder by its id.
		 * 
		 * @param id The ladder id as specified in the level xml file.
		 * @return the ladder with the specified id
		 */
		public function getLadderById(lId:int):Ladder
		{
			for (var i:int = 0; i < ladders.length; i++)
			{
				if (ladders[i].id == lId) 
					return ladders[i];
			}
			
			return null;
		}
		
		/**
		 * get a platform by its id. This is useful when you want to wire some action to a specific platform (ex. open a gate upon touching a platform)
		 * 
		 * @param id The platform id as specified in the level xml file.
		 * @return the platform with the specified id
		 */
		public function getItemById(id:int, groupId:String = "default"):ImageItem
		{
			if (groups[groupId]) 
			{
				for (var i:int = 0; i < groups[groupId].length; i++)
				{
					if (groups[groupId][i].id == id)
						return groups[groupId][i];
				}
			}
			
			return null;
		}
		
		/**
		 * add a custom item DisplayObject to the world, assign a unqie groupId to be able handle object with the same object id together
		 * 
		 * @param	item	the DisplayObject to be added to the world
		 * @param	groupId	item groupId, items with the same groupId can be use in #getItemsByGroupId(), #collide(goup1, group2)
		 */
		public function addItem(item:DisplayObject, groupId:String = "default"):void
		{
			if (!groups[groupId]) 
				groups[groupId] = new Vector.<DisplayObject>();
			
			view.addChild(item);
			
			item.name = groupId;
			
			groups[groupId].push(item);
		}
		
		/**
		 * remove an item from the world
		 * 
		 * @param	item the item to be removed from the world
		 */
		public function removeItem(item:DisplayObject):void
		{
			for (var i:int = 0; i < groups[item.name].length; i++)
			{
				if (groups[item.name][i] == item)
				{
					groups[item.name].splice(i, 1);
					break;
				}
			}
			
			if (groups[item.name].length == 0)
				delete groups[item.name];
			
			view.removeChild(item);
		}
		
		/**
		 * add detection for overlaps among objects beloning to 2 groups, when 2 object from each of the two groups cliide, an OverlapEvent event is fired
		 * 
		 * @param	groupId1	id of the first objects group
		 * @param	groupId2	id of the seccond objects group
		 * 
		 * @see #addItem()
		 */
		public function addOverlap(groupId1:String, groupId2:String):void
		{
			overlapGroups.push([groupId1, groupId2]);
		}
		
		/**
		 * draws the level using colored rectangles. This is useful to view the level before adding any graphics. Useful during development.
		 */
		public function drawDebug():void
		{
			for (var i:int = 0; i < areas.length; i++)
				areas[i].drawDebug();
			
			for (i = 0; i < platforms.length; i++)
				platforms[i].drawDebug();
			
			for (i = 0; i < ladders.length; i++)
				ladders[i].drawDebug();
			
			if (hero)
				hero.drawDebug();
		}
		
		/**
		 * pause / unpause the game
		 * 
		 * @param	yes true to pause, false to unpause
		 */
		public function pause(yes:Boolean = true):void
		{
			paused = yes;
			
			if (yes)
			{
				TweenMax.pauseAll();
			}
			else
				TweenMax.resumeAll();
		}
		
		/**
		 * update function of the world, should be called each frame to update the world
		 */
		public function update():void
		{
			if (paused) return;
			
			hero.update();
			
			if (hero.controller.isDown(hero.controller.builtInControls.up) && currLadder && hero.y > currLadder.y)
			{
				hero.y -= hero.ySpeedMax;
				
				if (!hero.onLadder)
				{
					evt = new PlatformEvent(PlatformEvent.LEAVE_FLOOR);
					evt.platform = currPlatform;
					dispatchEvent(evt);
					
					hero.xSpeed = 0;
					hero.onLadder = true;
					hero.onGround = false;
					currPlatform = null;
					
					if (!hero.allowLadderSideMove) hero.x = currLadder.x + currLadder.w * .5;
				}
			}
			
			if (hero.controller.isDown(hero.controller.builtInControls.down) && currLadder && hero.y < currLadder.y + currLadder.height)
			{
				hero.y += hero.ySpeedMax;
				
				if (!hero.onLadder)
				{
					evt = new PlatformEvent(PlatformEvent.LEAVE_FLOOR);
					evt.platform = currPlatform;
					dispatchEvent(evt);
					
					hero.xSpeed = 0;
					hero.onLadder = true;
					hero.onGround = false;
					currPlatform = null;
					
					if (!hero.allowLadderSideMove)
						hero.x = currLadder.x + currLadder.w * .5;
				}
			}
			
			if (hero.onGround)
			{
				collideHeroCurrPlatform();
			}
			else // on air
			{
				if (!hero.onLadder)
				{
					hero.ySpeed += gravity * viscosity;
					hero.y += hero.ySpeed * viscosity;
				}
			}
			
			hero.x += hero.xSpeed;
			
			if (!(hero.onLadder && hero.controller.isDown(hero.controller.builtInControls.down) && hero.y < currLadder.y + currLadder.h))
			{
				collideHeroPlatforms();
				collideHeroLadders();
			}
			
			collideHeroAreas();
			updateGroupsOverlap();
			
			camera.update();
			background.update();
			
			hero.lastX = hero.x;
			hero.lastY = hero.y;
		}
		
		public function getCurrentItemsCount(groupId:String):int
		{
			if (groups[groupId])
				return groups[groupId].length;
			
			return 0;
		}
		
		public function getInitialItemsCount(groupId:String):int
		{
			if (initialItemsCounts[groupId])
				return initialItemsCounts[groupId];
			
			return 0;
		}
		
		private function updateGroupsOverlap():void
		{
			for (var i:int = 0; i < overlapGroups.length; i++)
				checkOverlap(overlapGroups[i][0], overlapGroups[i][1]); 
		}
		
		private function checkOverlap(goupId1:String, goupId2:String):void
		{
			if (!groups[goupId1] || !groups[goupId2]) return;
			
			var evt:OverlapEvent;
			
			// check overlaps start
			for (var i:int = 0; i < groups[goupId1].length; i++)
			{
				for (var j:int = 0; j < groups[goupId2].length; j++)
				{
					if (ovlapping(groups[goupId1][i], groups[goupId2][j]) && !overlapExist(groups[goupId1][i], groups[goupId2][j]))
					{
						overlaps.push(new Overlap(groups[goupId1][i], groups[goupId2][j]));
						
						evt = new OverlapEvent(OverlapEvent.OVERLAP_START);
						evt.overlap.groupId1 = goupId1;
						evt.overlap.groupId2 = goupId2;
						evt.overlap.item1 = groups[goupId1][i];
						evt.overlap.item2 = groups[goupId2][j];
						dispatchEvent(evt);
						break;
					}
				}
			}
			
			// check overlaps end
			for (i = overlaps.length - 1; i >= 0; i--)
			{
				if (!ovlapping(overlaps[i].item1, overlaps[i].item2)) 
				{
					evt = new OverlapEvent(OverlapEvent.OVERLAP_END);
					evt.overlap = overlaps[i];
					dispatchEvent(evt);
					
					overlaps.splice(i, 1);
				}
			}
		}
		
		private function overlapExist(item1:DisplayObject, item2:DisplayObject):Boolean 
		{
			for (var i:int = 0; i < overlaps.length; i++) 
			{
				if (overlaps[i].itemsExist(item1, item2)) 
					return true;
			}
			
			return false;
		}
		
		private function ovlapping(item1:DisplayObject, item2:DisplayObject):Boolean 
		{
			var item1X:Number = item1.x - item1.pivotX - (item1 is FeglaItem && FeglaItem(item1).view ? FeglaItem(item1).view.pivotX : 0);
			var item1Y:Number = item1.y - item1.pivotY - (item1 is FeglaItem && FeglaItem(item1).view ? FeglaItem(item1).view.pivotY : 0);
			var item2X:Number = item2.x - item2.pivotX - (item2 is FeglaItem && FeglaItem(item1).view ? FeglaItem(item2).view.pivotX : 0);
			var item2Y:Number = item2.y - item2.pivotY - (item2 is FeglaItem && FeglaItem(item1).view ? FeglaItem(item2).view.pivotY : 0);
			
			var item1W:Number = item1 is FeglaItem ? FeglaItem(item1).w : item1.width;
			var item1H:Number = item1 is FeglaItem ? FeglaItem(item1).h : item1.height;
			var item2W:Number = item2 is FeglaItem ? FeglaItem(item2).w : item2.width;
			var item2H:Number = item2 is FeglaItem ? FeglaItem(item2).h : item2.height;
			
			if (item1X < item2X + item2W &&
				item1X + item1W > item2X &&
				item1Y < item2Y + item2H &&
				item1Y + item1H > item2Y) return true;
			
			return false;
		}
		
		private function collideHeroCurrPlatform():void
		{
			var pf_w:Number = currPlatform.w;
			
			if (currPlatform.rotation != 0)
			{
				hero.y = currPlatform.y + (hero.x - currPlatform.x) * Math.tan(currPlatform.rotation);
				pf_w *= Math.cos(currPlatform.rotation);
			}
			else
				hero.y = currPlatform.y;
			
			if (currPlatform.moving)
				hero.x += currPlatform.x - currPlatform.lastX;
			
			if (currPlatform.forceX > 0)
				hero.xSpeed += currPlatform.forceX;
			
			if (hero.x < currPlatform.x - hero.w/2 || hero.x > currPlatform.x + pf_w + hero.w/2) // fell off a currPlatform
			{
				var evt:PlatformEvent = new PlatformEvent(PlatformEvent.LEAVE_FLOOR);
				evt.platform = currPlatform;
				dispatchEvent(evt);
				
				hero.onGround = false;
				hero.ySpeed = 0;
				currPlatform = null;
			}
		}
		
		private function collideHeroPlatforms():void
		{
			for (var i:int = 0; i < platforms.length; i++)
			{
				if (!platforms[i].active)
					continue;
				
				if (platforms[i].type == Platform.OneWay) 
				{
					var yi:Number = platforms[i].y + (hero.x - platforms[i].x) * Math.tan(platforms[i].rotation);
					
					if (hero.x > platforms[i].x - hero.w/2 && hero.x < platforms[i].x + platforms[i].w * Math.cos(platforms[i].rotation) + hero.w/2 &&
						hero.y > yi && hero.lastY <= yi) // touched ground
					{
						hero.onGround = true;
						hero.ySpeed = 0;
						hero.y = yi;
						currPlatform = platforms[i];
						
						if (currPlatform.friction > 0)
							hero.currFriction = currPlatform.friction;
						else
							hero.currFriction = hero.friction;
						
						if (currPlatform.forceY != 0)
						{
							hero.xSpeed = -currPlatform.forceY * Math.sin(currPlatform.rotation);
							hero.ySpeed = currPlatform.forceY * Math.cos(currPlatform.rotation);
							
							currPlatform = null;
							hero.onGround = false;
							hero.onLadder = false;
						}
						
						evt = new PlatformEvent(PlatformEvent.TOUCH_FLOOR);
						evt.platform = currPlatform;
						dispatchEvent(evt);
					}
				}
				else // block
				{
					if (hero.x > platforms[i].x - hero.w/2 && hero.x < platforms[i].x + platforms[i].w + hero.w/2 &&
						hero.y > platforms[i].y && hero.lastY <= platforms[i].y) // from above
					{
						hero.onGround = true;
						hero.ySpeed = 0;
						hero.y = platforms[i].y;
						currPlatform = platforms[i];
						
						if (currPlatform.friction > 0)
							hero.currFriction = currPlatform.friction;
						else
							hero.currFriction = hero.friction;
						
						evt = new PlatformEvent(PlatformEvent.TOUCH_FLOOR);
						evt.platform = currPlatform;
						dispatchEvent(evt);
					}
					else if (hero.x > platforms[i].x - hero.w/2 && hero.x < platforms[i].x + platforms[i].w + hero.w/2 &&
						hero.y - hero.h < platforms[i].y + platforms[i].h && hero.lastY - hero.height >= platforms[i].lastY + platforms[i].h) // from below
					{
						hero.ySpeed = 0;
						hero.y = hero.lastY;
					}
					else if (hero.y > platforms[i].y && hero.y - hero.h < platforms[i].y + platforms[i].h &&
						hero.x + hero.w * .5 > platforms[i].x && hero.lastX + hero.w * .5 <= platforms[i].lastX) // from left
					{
						hero.xSpeed = 0;
						hero.x = platforms[i].x - hero.w / 2;
					}
					else if (hero.y > platforms[i].y && hero.y - hero.height < platforms[i].y + platforms[i].h &&
						hero.x - hero.w * .5 < platforms[i].x + platforms[i].w && hero.lastX - hero.w * .5 >= platforms[i].lastX + platforms[i].w) // from right
					{
						hero.xSpeed = 0;
						hero.x = platforms[i].x + platforms[i].w + hero.w / 2;
					}
				}
				
				platforms[i].lastX = platforms[i].x;
				platforms[i].lastY = platforms[i].y;
			}
		}
		
		private function collideHeroLadders():void
		{
			if (currLadder)
			{
				if (hero.x < currLadder.x || hero.x > currLadder.x + currLadder.w ||
					hero.y <= currLadder.y || hero.y >= currLadder.y + currLadder.h) // left ladder
				{
					currLadder = null;
					hero.onLadder = false;
				}
			}
			else
			{
				for (var i:int = 0; i < ladders.length; i++)
				{
					if (hero.x > ladders[i].x && hero.x < ladders[i].x + ladders[i].w &&
						hero.y < ladders[i].y + ladders[i].h + hero.h/2 && hero.y >= ladders[i].y) // touched ladder
					{
						currLadder = ladders[i];
						break;
					}
				}
			}
		}
		
		private function collideHeroAreas():void
		{
			var evt:AreaEvent;
			
			if (currArea)
			{
				if (hero.x < currArea.x || hero.x > currArea.x + currArea.w ||
					hero.y < currArea.y || hero.y - hero.h > currArea.y + currArea.h) // left area
				{
					evt = new AreaEvent(AreaEvent.LEAVE_AREA);
					evt.area = currArea;
					dispatchEvent(evt);
					
					currArea = null;
					viscosity = 1;
					//hero.xSpeed *= viscosity;
					//hero.ySpeed *= viscosity;
				}
			}
			else
			{
				for (var i:int = 0; i < areas.length; i++)
				{
					if (hero.x > areas[i].x && hero.x < areas[i].x + areas[i].w &&
						hero.y - hero.h < areas[i].y + areas[i].h && hero.y > areas[i].y) // entered area
					{
						currArea = areas[i];
						viscosity = currArea.viscosity;
						hero.xSpeed *= viscosity;
						hero.ySpeed *= viscosity;
						
						evt = new AreaEvent(AreaEvent.ENTER_AREA);
						evt.area = currArea;
						dispatchEvent(evt);
						break;
					}
				}
			}
		}
		
		private function onRemoved(e:Event):void 
		{
			removeEventListener(Event.REMOVED_FROM_STAGE, onRemoved);
			
			TweenMax.killAll();
		}
	}
}